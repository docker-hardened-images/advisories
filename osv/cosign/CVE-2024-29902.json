{
  "modified": "2024-04-10T22:12:59Z",
  "published": "2024-04-10T22:12:59Z",
  "schema_version": "1.5.0",
  "id": "CVE-2024-29902",
  "aliases": [
    "GHSA-88jx-383q-w4qc"
  ],
  "details": "### Summary\r\nA remote image with a malicious attachment can cause denial of service of the host machine running Cosign. This can impact other services on the machine that rely on having memory available such as a Redis database which can result in data loss. It can also impact the availability of other services on the machine that will not be available for the duration of the machine denial.\r\n\r\n### Details\r\nThe root cause of this issue is that Cosign reads the attachment from a remote image entirely into memory without checking the size of the attachment first. As such, a large attachment can make Cosign read a large attachment into memory; If the attachments size is larger than the machine has memory available, the machine will be denied of service. The Go runtime will make a SigKill after a few seconds of system-wide denial.\r\n\r\nThe root cause is that Cosign reads the contents of the attachments entirely into memory on line 238 below:\r\n\r\nhttps://github.com/sigstore/cosign/blob/9bc3ee309bf35d2f6e17f5d23f231a3d8bf580bc/pkg/oci/remote/remote.go#L228-L239\r\n\r\n...and prior to that, neither Cosign nor go-containerregistry checks the size of the attachment and enforces a max cap. In the case of a remote layer of `f *attached`, go-containerregistry will invoke this API:\r\n\r\nhttps://github.com/google/go-containerregistry/blob/a0658aa1d0cc7a7f1bcc4a3af9155335b6943f40/pkg/v1/remote/layer.go#L36-L40\r\n```golang\r\nfunc (rl *remoteLayer) Compressed() (io.ReadCloser, error) {\r\n\t// We don't want to log binary layers -- this can break terminals.\r\n\tctx := redact.NewContext(rl.ctx, \"omitting binary blobs from logs\")\r\n\treturn rl.fetcher.fetchBlob(ctx, verify.SizeUnknown, rl.digest)\r\n}\r\n```\r\n\r\nNotice that the second argument to `rl.fetcher.fetchBlob` is `verify.SizeUnknown` which results in not using the `io.LimitReader` in `verify.ReadCloser`:\r\nhttps://github.com/google/go-containerregistry/blob/a0658aa1d0cc7a7f1bcc4a3af9155335b6943f40/internal/verify/verify.go#L82-L100\r\n```golang\r\nfunc ReadCloser(r io.ReadCloser, size int64, h v1.Hash) (io.ReadCloser, error) {\r\n\tw, err := v1.Hasher(h.Algorithm)\r\n\tif err != nil {\r\n\t\treturn nil, err\r\n\t}\r\n\tr2 := io.TeeReader(r, w) // pass all writes to the hasher.\r\n\tif size != SizeUnknown {\r\n\t\tr2 = io.LimitReader(r2, size) // if we know the size, limit to that size.\r\n\t}\r\n\treturn \u0026and.ReadCloser{\r\n\t\tReader: \u0026verifyReader{\r\n\t\t\tinner:    r2,\r\n\t\t\thasher:   w,\r\n\t\t\texpected: h,\r\n\t\t\twantSize: size,\r\n\t\t},\r\n\t\tCloseFunc: r.Close,\r\n\t}, nil\r\n}\r\n```\r\n\r\n### Impact\r\nThis issue can allow a supply-chain escalation from a compromised registry to the Cosign user: If an attacher has compromised a registry or the account of an image vendor, they can include a malicious attachment and hurt the image consumer. \r\n\r\n### Remediation\r\n\r\nUpdate to the latest version of Cosign, which limits the number of attachments. An environment variable can override this value.",
  "affected": [
    {
      "package": {
        "ecosystem": "DHI",
        "name": "cosign",
        "purl": "pkg:dhi/cosign"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              "introduced": "0"
            },
            {
              "fixed": "2.2.4"
            }
          ]
        }
      ],
      "database_specific": {
        "source_ecosystem": "go",
        "source_package": "github.com/sigstore/cosign"
      }
    }
  ],
  "references": [
    {
      "type": "WEB",
      "url": "https://github.com/sigstore/cosign/security/advisories/GHSA-88jx-383q-w4qc"
    }
  ]
}