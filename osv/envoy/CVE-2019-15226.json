{
  "modified": "2019-11-08T20:37:15Z",
  "published": "2019-11-08T20:37:15Z",
  "schema_version": "1.5.0",
  "id": "CVE-2019-15226",
  "aliases": [
    "GHSA-mxrr-6x92-4x7v"
  ],
  "details": "# CVE-2019-15226\r\n\r\n## Brief description\r\nUpon receiving each incoming request header data, Envoy will iterate over existing request headers to verify that the total size of the headers stays below a maximum limit. The implementation in versions 1.10.0 and after for HTTP/1.x traffic and all versions of Envoy for HTTP/2 traffic had O(n^2) performance characteristics. A remote attacker may craft a request that stays below the maximum request header size but consists of many thousands of small headers to consume CPU and result in a denial-of-service attack.\r\n\r\n## CVSS\r\n[CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H](https://www.first.org/cvss/calculator/3.0#CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H) (7.5, High)\r\n\r\n## Affected version(s)\r\nEnvoy 1.10.0 and after are affected for HTTP/1.x traffic. All Envoy versions for HTTP/2 traffic. Fix will be in 1.11.2.\r\n\r\n## Affected component(s)\r\nHTTP/1.x codec, HTTP/2 codec, HeaderMap implementation\r\n\r\n## Attack vector(s)\r\nA request that consists of thousands of very small headers. For example, an HTTP/1.1 POST request containing thousands of very small headers. \r\n\r\n## Discover(s)/Credits\r\nAsra Ali, Google\r\nHarvey Tuch, Google\r\n\r\n## Example exploit or proof-of-concept\r\nX sends an HTTP/1.1 POST request with 10,000 tiny headers “x-0: ”, …, “x-10000: ” each second. \r\nUpon receiving each incoming header value, Envoy verifies that the total request header size is below the maximum limit using a for loop over the existing header map in the implementation for [byteSize()](https://github.com/envoyproxy/envoy/blob/6ff0bce8ff417a252cde4d04dfb9cba2bab463d8/source/common/http/header_map_impl.cc#L454).\r\n\r\n## Details\r\nBoth the HTTP/1.1 and HTTP/2 codec limit the maximum size of all request headers. To verify this limit, the `byteSize()` method of the HeaderMap is called. This method returns the estimated size of the HeaderMap by calculating the sum of each HeaderEntry key-value pair in the HeaderMap. Each time Envoy adds a header, it calls `byteSize()` to verify that the resulting HeaderMap will remain below the limit. This results in an O(n^2) operation in the number of headers. \r\n\r\nThe issue was first noticed via a timeout in Envoy’s wire-level HTTP/1.1 fuzzer: https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=16325\r\n\r\n## Mitigations\r\nIn some situations, the maximum request header size can likely be smaller than the default limit of 60 KiB. This is configurable in the HTTP Connection Manager configuration. Lowering this limit can reduce the number of request headers, and possibly mitigate excessive CPU consumption.\r\n\r\n## Detection\r\nEnvoy’s exposes the loop duration and poll delay to monitor performance of the event loops on worker threads, so it is possible to examine these statistics to detect suspicious CPU resource consumption. Elevated worker thread dispatcher.loop_duration_us statistics will provide circumstantial evidence of an ongoing attack. These statistics can be enabled by setting enable_dispatcher_stats to true.\r\n\r\n## References\r\n* CVE: https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-15226",
  "affected": [
    {
      "package": {
        "ecosystem": "DHI",
        "name": "envoy",
        "purl": "pkg:dhi/envoy"
      },
      "ranges": [
        {
          "type": "SEMVER",
          "events": [
            {
              "introduced": "0"
            },
            {
              "fixed": "1.11.2"
            }
          ]
        }
      ],
      "database_specific": {
        "source_ecosystem": "",
        "source_package": ""
      }
    }
  ],
  "references": [
    {
      "type": "WEB",
      "url": "https://github.com/envoyproxy/envoy/security/advisories/GHSA-mxrr-6x92-4x7v"
    }
  ]
}